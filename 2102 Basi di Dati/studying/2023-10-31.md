---
type: university
date: 2023-10-31
subjectId: 2102
year: 2
semester: 1
---
#university #studying #subject-2102
### 2023-10-31
> [!summary] Basi di Dati

## Algebra Relazionale

Simboli:
- $\pi$ Proiezione (filtra le colonne)
- $\delta$ Ridenominazione (rinomina le colonne)
- $\sigma$ Selezione (filtra le righe)
- $\times$ Prodotto cartesiano
- $\bowtie$ Natural Join (unisce due tabelle confrontando le colonne con lo stesso nome)
- $\bowtie_\text{a>b}$ Theta Join (unisce due tabelle confrontando le colonne specificate)
- $\bowtie_\text{a=b}$ Equi Join (unisce due tabelle confrontando le colonne specificate esclusivamente con l'operatore $=$)
- $\cup$ Unione
- $\cap$ Intersezione
- $-$ Differenza
- $\bowtie^{\longleftrightarrow}$ Full Natural Outer-Join (unisce due tabelle confrontando la colonne uguali e prendendo anche le righe nulle di entrambe le tabelle) \[Al posto della freccia puoi scrivere FULL\]
- $\bowtie^{\longleftarrow}$ Full Natural Left-Join (unisce due tabelle confrontando la colonne uguali e prendendo anche le righe nulle della tabella a destra). \[Al posto della freccia puoi scrivere LEFT\]
- $\bowtie^{\longrightarrow}$ Full Natural Right-Join (unisce due tabelle confrontando la colonne uguali e prendendo anche le righe nulle della tabella a sinistra) \[Al posto della freccia puoi scrivere RIGHT\]
- $\ltimes$ Semi-Join Left (unisce le due tabelle con un EquiJoin e fa la proiezione dei campi della tabella a sinistra)
- $\rtimes$ Semi-Join Right (unisce le due tabelle con un EquiJoin e fa la proiezione dei campi della tabella a destra)
- $\cup^{\longleftrightarrow}$ Unione Esterna (fa l'unione anche se ci sono colonne diverse. Le colonne diverse vengono messe $=null$)
- $\div$ Divisione (prende le righe della tabella a sinistra che hanno corrispondenza con tutte le righe della tabella a destra)

> [!faq] Esempio
```
Prodotto(costruttore, id_modello, tipo)
PC(id_modello, velocità, ram, hd_size, risoluzione, prezzo)
Laptop(id_modello, velocità, ram, hd_size, risoluzione, prezzo)
Stampante(id_modello, colore, tipo, prezzo)  

Trovare gli hd_size che sono presenti in due o più PC:
R1 = RIDENOMINAZIONE[P1_*](PC) EQUIJOIN[P1_hd_size = P2_hd_size, P1_id_modello > P2_id_modello] RIDENOMINAZIONE[P2_*](PC)
R2 = PROIEZIONE[hd_size](R1)

Trovare i costruttori di computer (PC o Laptop) con la velocità più alta;

R1 = proiezione[id_modello, velocita](PC) UNIONE proiezione[id_modello, velocita](Laptop)
R2 = R1  
R3 = proiezione[R1.id_modello](selezione[R1.velocita < R2.velocita](R1 X R2))
R4 = proiezione[id_modello](Prodotto) - R3
R5 = proiezione[costruttore](Prodotto NATURAL JOIN R4)

SQL:
SELECT costruttore
FROM Prodotto
WHERE velocità IN (
	SELECT MAX(IF(PC.velocità > Laptop.velocità; PC.velocità; Laptop.velocità))
	FROM (SELECT * FROM PC), (SELECT * FROM Laptop)
)
```

## SQL
- `UNION [ALL]`/`INTERSECT [ALL]`/`EXCEPT [ALL]` (l'`ALL` indica di mantenere i duplicati)
- La divisione si implementa con un doppio `NOT EXISTS`

### Trigger
```
CREATE TRIGGER TriggerName
{ before | after }
{ insert | delete | update [of Column] } on Table
[referencing
	{[old_table [as] OldTableAlias]
	[new_table [as] NewTableAlias] } |
	{[old [row] [as] OldTupleName]
	[new [row] [as] NewTupleName] }]
[for each { row | statement }]
[when Condition]
SQLStatements
```

esempio
```
create trigger FileDeletedInvoices
after delete on Invoice
referencing old_table as OldInvoiceSet
insert into DeletedInvoices
	(select *
	from OldInvoiceSet)
```

Quando si usa "for each statement" invece di "for each row" in "SQLStatements" ci potranno finire le classiche operazioni come INSERT INTO, UPDATE, DELETE, ecc.
Nel caso di "for each row", invece, si aggiunge la possibilità di utilizzare una sintassi propria.
Si usa `SET` per aggiornare i campi NEW, ad esempio:
`SET NEW.total = 5 * OLD.total`

### View
```
CREATE VIEW NomeView(col1, col2) AS
SELECT ...
```
`col1` e `col2` sono i nomi delle colonne ritornate. Possono essere omesse (verrebbero prese in automatico dai 
campi del select).

`WITH CHECK OPTION` fa controllare in fase di inserimento all'interno della view che vengano rispettate le condizioni del `WHERE`.
### Check
Si mette nella definizione della tabelle
```
CHECK (query_che_ritorna_un_booleano)
```

es. `CHECK ((SELECT MIN(prezzo) FROM prodotti) >= 0)`

Se serve fare un controllo **intra-relazionale** (che si spalma su più tabelle) è necessaria la seguente sintassi:
```
CREATE ASSERTION nome_asserzione
CHECK (query_che_ritorna_un_booleano)
```

### Procedure
```
CREATE PROCEDURE nome_procedura(IN p1 INT)
BEGIN
	blocco_istruzioni
END
```
`IN` è opzionale

### Transazioni
```
START TRANSACTION;
query1
query2
...
queryn
COMMIT WORK;
```

## Sintassi body trigger/funzioni/procedure
### DECLARE
##### Per le variabili
```
DECLARE variabile TIPO [DEFAULT valore_default]
```
##### Per i cursori
*vedi sotto sezione dedicata*

### IF
```
IF (condizione) THEN
	body_if
END IF;
```

Sintassi completa con `else`:
```
IF (condizione) THEN
	body_if
ELSEIF (condizione) THEN
	body_elseif
ELSE
	body_else
END IF;
```

### WHILE
```
WHILE (condizione) DO
	body_while
END WHILE;
```

### REPEAT UNTIL
```
REPEAT
	body_repeatuntil
UNTIL (condizione)
END REPEAT;
```

### LOOP
```
loop_label: LOOP
	...istruzioni...
	IF (condizione)
		LEAVE loop_label;
	END IF
	...istruzioni...
	IF (condizione)
		ITERATE loop_label;
	END IF
	...istruzioni...
END LOOP
```

### CURSOR
```
DECLARE cursor_name CURSOR FOR SELECT ...

OPEN cursor_name;

DECLARE stop_iterating INT DEFAULT 0
DECLARE CONTINUE HANDLER FOR NOT FOUND SET stop_iterating = 1

...

REPEAT
	...
	FETCH cursor_name INTO var1, var2, ..., varn;
	...
UNTIL stop_iterating

...

CLOSE cursor_name;
```
